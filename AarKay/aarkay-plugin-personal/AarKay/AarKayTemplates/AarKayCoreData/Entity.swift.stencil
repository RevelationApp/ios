//     _____                  ____  __.
//    /  _  \ _____ _______  |    |/ _|____  ___.__.
//   /  /_\  \\__  \\_  __ \ |      < \__  \<   |  |
//  /    |    \/ __ \|  | \/ |    |  \ / __ \\___  |
//  \____|__  (____  /__|    |____|__ (____  / ____|
//          \/     \/                \/    \/\/
//
//  Generated by AarKay on 27/12/18.
//  Copyright Â© 2018 RahulKatariya. All rights reserved.
//

import Foundation
import CoreData
{% if domainModel and domainModuleName %}import {{ domainModuleName }}{% endif %}

@objc(CD{{ name }})
class CD{{ name }}: {% if parentEntity %}CD{{ parentEntity }}{% else %}NSManagedObject{% endif %}, {% if domainModel %}CDDomainable{% else %}CDModelable{% endif %} {
    typealias CDModel = CD{{ name }}
    {% if domainModel %}
    typealias DomainModel = {{ domainModel }}
    {% endif %}
    {% if attributes %}

    {% for attribute in attributes %}
    @NSManaged var {{ attribute.property.name }}: {{ attribute.property.type }}
    {% endfor %}
    {% endif %}
    {% if relationships %}
    {% for relationship in singleRelationships %}
    @NSManaged var {{ relationship.property.name }}: CD{{ relationship.property.type }}?
    {% endfor %}
    {% endif %}
    {% if collectionRelationships %}
    {% for relationship in collectionRelationships %}
    @NSManaged var {{ relationship.property.name }}: NSSet?
    {% endfor %}
    {% endif %}
    {% if domainModel %}

    static func asDomain(item: CD{{ name }}) -> {{ domainModel }} {
        /// <aarkay asDomain>
        
        /// </aarkay>
    }
    {% endif %}
}
{% for constraint in constraints %}

// MARK: Fetch Helper for {{ constraint.property.name }}
extension CD{{ name }} {
    static func fetch({{ constraint.property.name }}: {{ constraint.property.type }}, context: NSManagedObjectContext) throws -> CD{{ name }}? {
        let predicate = NSPredicate(format: "id == %d", id)
        let result = try CD{{ name }}.fetch(context: context, predicate: predicate).first
        if result == nil { assertionFailure("Movie with \(id) doesn't exist in db") }
        return result
    }

    static func exists({{ constraint.property.name }}: {{ constraint.property.type }}, context: NSManagedObjectContext) throws -> Bool {
        let predicate = NSPredicate(format: "{{ constraint.property.name }} == %{% if constraint.usesScalarValueType %}d{% else %}@{% endif %}", {{ constraint.property.name }})
        let count = try CD{{ name }}.count(context: context, predicate: predicate)
        assert(count <= 1, "More than 1 {{ name }} records found in db")
        return count == 1
    }
}
{% endfor %}
{% for relationship in collectionRelationships %}

// MARK: Generated accessors for {{ relationship.property.name }}
extension CD{{ name }} {
    @objc(add{{ relationship.property.name|upperFirstLetter }}Object:)
    @NSManaged public func addTo{{ relationship.property.name|upperFirstLetter }}(_ value: {{ relationship.type }})

    @objc(remove{{ relationship.property.name|upperFirstLetter }}Object:)
    @NSManaged public func removeFrom{{ relationship.property.name|upperFirstLetter }}(_ value: {{ relationship.type }})

    @objc(add{{ relationship.property.name|upperFirstLetter }}:)
    @NSManaged public func addTo{{ relationship.property.name|upperFirstLetter }}(_ values: NSSet)

    @objc(remove{{ relationship.property.name|upperFirstLetter }}:)
    @NSManaged public func removeFrom{{ relationship.property.name|upperFirstLetter }}(_ values: NSSet)
}
{% endfor %}
